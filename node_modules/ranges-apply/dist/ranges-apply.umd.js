/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */

var rangesApply=(()=>{var c=Object.defineProperty;var N=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var T=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var v=(s,n,a)=>n in s?c(s,n,{enumerable:!0,configurable:!0,writable:!0,value:a}):s[n]=a,y=(s,n)=>{for(var a in n||(n={}))T.call(n,a)&&v(s,a,n[a]);if(w)for(var a of w(n))R.call(n,a)&&v(s,a,n[a]);return s};var D=s=>c(s,"__esModule",{value:!0});var j=(s,n)=>{for(var a in n)c(s,a,{get:n[a],enumerable:!0})},A=(s,n,a,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let l of x(n))!T.call(s,l)&&(a||l!=="default")&&c(s,l,{get:()=>n[l],enumerable:!(t=N(n,l))||t.enumerable});return s};var S=(s=>(n,a)=>s&&s.get(n)||(a=A(D({}),n,1),s&&s.set(n,a),a))(typeof WeakMap!="undefined"?new WeakMap:0);var q={};j(q,{rApply:()=>F,version:()=>M});var H={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function d(s,n){if(!Array.isArray(s)||!s.length)return s;let a=y(y({},H),n),t,l;if(a.strictlyTwoElementsInRangeArrays&&!s.every((o,u)=>!Array.isArray(o)||o.length!==2?(t=u,l=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${t}th range (${JSON.stringify(s[t],null,4)}) has not two but ${l} elements!`);if(!s.every((o,u)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(t=u,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${t}th range (${JSON.stringify(s[t],null,4)}) does not consist of only natural numbers!`);let r=s.length**2,p=0;return Array.from(s).sort((o,u)=>(a.progressFn&&(p+=1,a.progressFn(Math.floor(p*100/r))),o[0]===u[0]?o[1]<u[1]?-1:o[1]>u[1]?1:0:o[0]<u[0]?-1:1))}var b={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function $(s,n){function a(e){return e&&typeof e=="object"&&!Array.isArray(e)}if(!Array.isArray(s)||!s.length)return null;let t;if(n)if(a(n)){if(t=y(y({},b),n),t.progressFn&&a(t.progressFn)&&!Object.keys(t.progressFn).length)t.progressFn=null;else if(t.progressFn&&typeof t.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof t.progressFn}", equal to ${JSON.stringify(t.progressFn,null,4)}`);if(![1,2,"1","2"].includes(t.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);if(typeof t.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof t.joinRangesThatTouchEdges}", equal to ${JSON.stringify(t.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(n,null,4)} (type ${typeof n})`);else t=y({},b);let l=s.filter(e=>Array.isArray(e)).map(e=>[...e]).filter(e=>e[2]!==void 0||e[0]!==e[1]),r,p,o;t.progressFn?r=d(l,{progressFn:e=>{o=Math.floor(e/5),o!==p&&(p=o,t.progressFn(o))}}):r=d(l);let u=r.length-1;for(let e=u;e>0;e--)t.progressFn&&(o=Math.floor((1-e/u)*78)+21,o!==p&&o>p&&(p=o,t.progressFn(o))),(r[e][0]<=r[e-1][0]||!t.joinRangesThatTouchEdges&&r[e][0]<r[e-1][1]||t.joinRangesThatTouchEdges&&r[e][0]<=r[e-1][1])&&(r[e-1][0]=Math.min(r[e][0],r[e-1][0]),r[e-1][1]=Math.max(r[e][1],r[e-1][1]),r[e][2]!==void 0&&(r[e-1][0]>=r[e][0]||r[e-1][1]<=r[e][1])&&r[e-1][2]!==null&&(r[e][2]===null&&r[e-1][2]!==null?r[e-1][2]=null:r[e-1][2]!=null?+t.mergeType==2&&r[e-1][0]===r[e][0]?r[e-1][2]=r[e][2]:r[e-1][2]+=r[e][2]:r[e-1][2]=r[e][2]),r.splice(e,1),e=r.length);return r.length?r:null}var J=!0,m="Invariant failed";function I(s,n){if(!s){if(J)throw new Error(m);var a=typeof n=="function"?n():n,t=a?m+": "+a:m;throw new Error(t)}}var E="6.0.12";var M=E;function F(s,n,a){let t=0,l=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof s!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof s}, equal to: ${JSON.stringify(s,null,4)}`);if(n&&!Array.isArray(n))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof n}, equal to: ${JSON.stringify(n,null,4)}`);if(a&&typeof a!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof a}, equal to: ${JSON.stringify(a,null,4)}`);if(!n||!n.filter(i=>i).length)return s;let r;Array.isArray(n)&&Number.isInteger(n[0])&&Number.isInteger(n[1])?r=[Array.from(n)]:r=Array.from(n);let p=r.length,o=0;r.filter(i=>i).forEach((i,g)=>{if(a&&(t=Math.floor(o/p*10),t!==l&&(l=t,a(t))),!Array.isArray(i))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${g}th element not an array: ${JSON.stringify(i,null,4)}, which is ${typeof i}`);if(!Number.isInteger(i[0])){if(!Number.isInteger(+i[0])||+i[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its first element is not an integer, string index, but ${typeof i[0]}, equal to: ${JSON.stringify(i[0],null,4)}.`);r[g][0]=+r[g][0]}if(!Number.isInteger(i[1])){if(!Number.isInteger(+i[1])||+i[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${g}th element, array ${JSON.stringify(i,null,0)}. Its second element is not an integer, string index, but ${typeof i[1]}, equal to: ${JSON.stringify(i[1],null,4)}.`);r[g][1]=+r[g][1]}o+=1});let u=$(r,{progressFn:i=>{a&&(t=10+Math.floor(i/10),t!==l&&(l=t,a(t)))}});I(u);let e=u.length;if(e>0){let i=s.slice(u[e-1][1]);s=u.reduce((g,k,f,h)=>{a&&(t=20+Math.floor(f/e*80),t!==l&&(l=t,a(t)));let O=f===0?0:h[f-1][1],_=h[f][0];return`${g}${s.slice(O,_)}${h[f][2]||""}`},""),s+=i}return s}return S(q);})();
/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
