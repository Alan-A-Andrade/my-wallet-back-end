/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 8.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */

var rangesMerge=(()=>{var p=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames,m=Object.getOwnPropertySymbols;var y=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var f=(r,t,o)=>t in r?p(r,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[t]=o,u=(r,t)=>{for(var o in t||(t={}))y.call(t,o)&&f(r,o,t[o]);if(m)for(var o of m(t))R.call(t,o)&&f(r,o,t[o]);return r};var T=r=>p(r,"__esModule",{value:!0});var w=(r,t)=>{for(var o in t)p(r,o,{get:t[o],enumerable:!0})},E=(r,t,o,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of b(t))!y.call(r,i)&&(o||i!=="default")&&p(r,i,{get:()=>t[i],enumerable:!(s=h(t,i))||s.enumerable});return r};var j=(r=>(t,o)=>r&&r.get(t)||(o=E(T({}),t,1),r&&r.set(t,o),o))(typeof WeakMap!="undefined"?new WeakMap:0);var x={};w(x,{defaults:()=>c,rMerge:()=>O,version:()=>F});var v={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function d(r,t){if(!Array.isArray(r)||!r.length)return r;let o=u(u({},v),t),s,i;if(o.strictlyTwoElementsInRangeArrays&&!r.every((a,l)=>!Array.isArray(a)||a.length!==2?(s=l,i=a.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${s}th range (${JSON.stringify(r[s],null,4)}) has not two but ${i} elements!`);if(!r.every((a,l)=>!Array.isArray(a)||!Number.isInteger(a[0])||a[0]<0||!Number.isInteger(a[1])||a[1]<0?(s=l,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${s}th range (${JSON.stringify(r[s],null,4)}) does not consist of only natural numbers!`);let n=r.length**2,g=0;return Array.from(r).sort((a,l)=>(o.progressFn&&(g+=1,o.progressFn(Math.floor(g*100/n))),a[0]===l[0]?a[1]<l[1]?-1:a[1]>l[1]?1:0:a[0]<l[0]?-1:1))}var $="8.0.12";var F=$,c={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function O(r,t){function o(e){return e&&typeof e=="object"&&!Array.isArray(e)}if(!Array.isArray(r)||!r.length)return null;let s;if(t)if(o(t)){if(s=u(u({},c),t),s.progressFn&&o(s.progressFn)&&!Object.keys(s.progressFn).length)s.progressFn=null;else if(s.progressFn&&typeof s.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof s.progressFn}", equal to ${JSON.stringify(s.progressFn,null,4)}`);if(![1,2,"1","2"].includes(s.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof s.mergeType}", equal to ${JSON.stringify(s.mergeType,null,4)}`);if(typeof s.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof s.joinRangesThatTouchEdges}", equal to ${JSON.stringify(s.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else s=u({},c);let i=r.filter(e=>Array.isArray(e)).map(e=>[...e]).filter(e=>e[2]!==void 0||e[0]!==e[1]),n,g,a;s.progressFn?n=d(i,{progressFn:e=>{a=Math.floor(e/5),a!==g&&(g=a,s.progressFn(a))}}):n=d(i);let l=n.length-1;for(let e=l;e>0;e--)s.progressFn&&(a=Math.floor((1-e/l)*78)+21,a!==g&&a>g&&(g=a,s.progressFn(a))),(n[e][0]<=n[e-1][0]||!s.joinRangesThatTouchEdges&&n[e][0]<n[e-1][1]||s.joinRangesThatTouchEdges&&n[e][0]<=n[e-1][1])&&(n[e-1][0]=Math.min(n[e][0],n[e-1][0]),n[e-1][1]=Math.max(n[e][1],n[e-1][1]),n[e][2]!==void 0&&(n[e-1][0]>=n[e][0]||n[e-1][1]<=n[e][1])&&n[e-1][2]!==null&&(n[e][2]===null&&n[e-1][2]!==null?n[e-1][2]=null:n[e-1][2]!=null?+s.mergeType==2&&n[e-1][0]===n[e][0]?n[e-1][2]=n[e][2]:n[e-1][2]+=n[e][2]:n[e-1][2]=n[e][2]),n.splice(e,1),e=n.length);return n.length?n:null}return j(x);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
