/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */

import{collWhitespace as y}from"string-collapse-leading-whitespace";var $={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function m(a,r){if(!Array.isArray(a)||!a.length)return a;let t={...$,...r},e,l;if(t.strictlyTwoElementsInRangeArrays&&!a.every((o,g)=>!Array.isArray(o)||o.length!==2?(e=g,l=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${e}th range (${JSON.stringify(a[e],null,4)}) has not two but ${l} elements!`);if(!a.every((o,g)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(e=g,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${e}th range (${JSON.stringify(a[e],null,4)}) does not consist of only natural numbers!`);let n=a.length**2,i=0;return Array.from(a).sort((o,g)=>(t.progressFn&&(i+=1,t.progressFn(Math.floor(i*100/n))),o[0]===g[0]?o[1]<g[1]?-1:o[1]>g[1]?1:0:o[0]<g[0]?-1:1))}var c="6.0.12";var d={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function f(a,r){function t(s){return s&&typeof s=="object"&&!Array.isArray(s)}if(!Array.isArray(a)||!a.length)return null;let e;if(r)if(t(r)){if(e={...d,...r},e.progressFn&&t(e.progressFn)&&!Object.keys(e.progressFn).length)e.progressFn=null;else if(e.progressFn&&typeof e.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof e.progressFn}", equal to ${JSON.stringify(e.progressFn,null,4)}`);if(![1,2,"1","2"].includes(e.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof e.mergeType}", equal to ${JSON.stringify(e.mergeType,null,4)}`);if(typeof e.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof e.joinRangesThatTouchEdges}", equal to ${JSON.stringify(e.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(r,null,4)} (type ${typeof r})`);else e={...d};let l=a.filter(s=>Array.isArray(s)).map(s=>[...s]).filter(s=>s[2]!==void 0||s[0]!==s[1]),n,i,o;e.progressFn?n=m(l,{progressFn:s=>{o=Math.floor(s/5),o!==i&&(i=o,e.progressFn(o))}}):n=m(l);let g=n.length-1;for(let s=g;s>0;s--)e.progressFn&&(o=Math.floor((1-s/g)*78)+21,o!==i&&o>i&&(i=o,e.progressFn(o))),(n[s][0]<=n[s-1][0]||!e.joinRangesThatTouchEdges&&n[s][0]<n[s-1][1]||e.joinRangesThatTouchEdges&&n[s][0]<=n[s-1][1])&&(n[s-1][0]=Math.min(n[s][0],n[s-1][0]),n[s-1][1]=Math.max(n[s][1],n[s-1][1]),n[s][2]!==void 0&&(n[s-1][0]>=n[s][0]||n[s-1][1]<=n[s][1])&&n[s-1][2]!==null&&(n[s][2]===null&&n[s-1][2]!==null?n[s-1][2]=null:n[s-1][2]!=null?+e.mergeType==2&&n[s-1][0]===n[s][0]?n[s-1][2]=n[s][2]:n[s-1][2]+=n[s][2]:n[s-1][2]=n[s][2]),n.splice(s,1),s=n.length);return n.length?n:null}var v=c;function u(a){return a!=null}function p(a){return Number.isInteger(a)&&a>=0}function h(a){return typeof a=="string"}var R={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},T=class{constructor(r){let t={...R,...r};if(t.mergeType&&t.mergeType!==1&&t.mergeType!==2)if(h(t.mergeType)&&t.mergeType.trim()==="1")t.mergeType=1;else if(h(t.mergeType)&&t.mergeType.trim()==="2")t.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);this.opts=t,this.ranges=[]}ranges;opts;add(r,t,e){if(r==null&&t==null)return;if(u(r)&&!u(t)){if(Array.isArray(r)){if(r.length){if(r.some(i=>Array.isArray(i))){r.forEach(i=>{Array.isArray(i)&&this.add(...i)});return}r.length&&p(+r[0])&&p(+r[1])&&this.add(...r)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(r,null,0)}) but second-one, "to" is not (${JSON.stringify(t,null,0)})`)}else if(!u(r)&&u(t))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(t,null,0)}) but first-one, "from" is not (${JSON.stringify(r,null,0)})`);let l=+r,n=+t;if(p(e)&&(e=String(e)),p(l)&&p(n)){if(u(e)&&!h(e)&&!p(e))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof e}, equal to:
${JSON.stringify(e,null,4)}`);if(u(this.ranges)&&Array.isArray(this.last())&&l===this.last()[1]){if(this.last()[1]=n,this.last()[2]===null||e===null,this.last()[2]!==null&&u(e)){let i=this.last()[2]&&this.last()[2].length>0&&(!this.opts||!this.opts.mergeType||this.opts.mergeType===1)?`${this.last()[2]}${e}`:e;this.opts.limitToBeAddedWhitespace&&(i=y(i,this.opts.limitLinebreaksCount)),h(i)&&!i.length||(this.last()[2]=i)}}else{this.ranges||(this.ranges=[]);let i=e!==void 0&&!(h(e)&&!e.length)?[l,n,e&&this.opts.limitToBeAddedWhitespace?y(e,this.opts.limitLinebreaksCount):e]:[l,n];this.ranges.push(i)}}else throw p(l)&&l>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof n}" equal to: ${JSON.stringify(n,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof l}" equal to: ${JSON.stringify(l,null,4)}`)}push(r,t,e){this.add(r,t,e)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=f(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(r=>u(r[2])?[r[0],r[1],y(r[2],this.opts.limitLinebreaksCount)]:r):this.ranges):null}wipe(){this.ranges=[]}replace(r){if(Array.isArray(r)&&r.length)if(Array.isArray(r[0])&&p(r[0][0]))this.ranges=Array.from(r);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(r[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};export{T as Ranges,R as defaults,v as version};
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
