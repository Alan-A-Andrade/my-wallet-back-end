/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */

var rangesPush=(()=>{var d=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var J=Object.getOwnPropertyNames,D=Object.getOwnPropertySymbols;var w=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var b=(n,e,t)=>e in n?d(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,p=(n,e)=>{for(var t in e||(e={}))w.call(e,t)&&b(n,t,e[t]);if(D)for(var t of D(e))x.call(e,t)&&b(n,t,e[t]);return n};var _=n=>d(n,"__esModule",{value:!0});var W=(n,e)=>{for(var t in e)d(n,t,{get:e[t],enumerable:!0})},j=(n,e,t,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let g of J(e))!w.call(n,g)&&(t||g!=="default")&&d(n,g,{get:()=>e[g],enumerable:!(r=I(e,g))||r.enumerable});return n};var F=(n=>(e,t)=>n&&n.get(e)||(t=j(_({}),e,1),n&&n.set(e,t),t))(typeof WeakMap!="undefined"?new WeakMap:0);var R=(n,e,t)=>(b(n,typeof e!="symbol"?e+"":e,t),t);var k={};W(k,{Ranges:()=>V,defaults:()=>S,version:()=>L});function $(n,e=1){let t="\xA0";function r(s){return Array.from(s).reverse().join("")}function g(s,a,i){let l=i?`
`:"\r",o=i?"\r":`
`;if(!s)return s;let E=0,y=0,c="";for(let u=0,v=s.length;u<v;u++)(s[u]===l||s[u]===o&&s[u-1]!==l)&&y++,`\r
`.includes(s[u])||s[u]===t?(E=0,s[u]===t?c+=s[u]:s[u]===l?y<=a&&(c+=s[u],s[u+1]===o&&(c+=s[u+1],u++)):s[u]===o&&(!s[u-1]||s[u-1]!==l)&&y<=a&&(c+=s[u])):(E++,!s[u+1]&&!y&&(c+=" "));return c}if(typeof n=="string"&&n.length){let s=1;typeof+e=="number"&&Number.isInteger(+e)&&+e>=0&&(s=+e);let a="",i="";if(!n.trim())a=n;else if(!n[0].trim()){for(let l=0,o=n.length;l<o;l++)if(n[l].trim()){a=n.slice(0,l);break}}if(n.trim()&&(n.slice(-1).trim()===""||n.slice(-1)===t)){for(let l=n.length;l--;)if(n[l].trim()){i=n.slice(l+1);break}}return`${g(a,s,!1)}${n.trim()}${r(g(r(i),s,!0))}`}return n}var C={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function T(n,e){if(!Array.isArray(n)||!n.length)return n;let t=p(p({},C),e),r,g;if(t.strictlyTwoElementsInRangeArrays&&!n.every((i,l)=>!Array.isArray(i)||i.length!==2?(r=l,g=i.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${r}th range (${JSON.stringify(n[r],null,4)}) has not two but ${g} elements!`);if(!n.every((i,l)=>!Array.isArray(i)||!Number.isInteger(i[0])||i[0]<0||!Number.isInteger(i[1])||i[1]<0?(r=l,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${r}th range (${JSON.stringify(n[r],null,4)}) does not consist of only natural numbers!`);let s=n.length**2,a=0;return Array.from(n).sort((i,l)=>(t.progressFn&&(a+=1,t.progressFn(Math.floor(a*100/s))),i[0]===l[0]?i[1]<l[1]?-1:i[1]>l[1]?1:0:i[0]<l[0]?-1:1))}var O="6.0.12";var A={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function N(n,e){function t(o){return o&&typeof o=="object"&&!Array.isArray(o)}if(!Array.isArray(n)||!n.length)return null;let r;if(e)if(t(e)){if(r=p(p({},A),e),r.progressFn&&t(r.progressFn)&&!Object.keys(r.progressFn).length)r.progressFn=null;else if(r.progressFn&&typeof r.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof r.progressFn}", equal to ${JSON.stringify(r.progressFn,null,4)}`);if(![1,2,"1","2"].includes(r.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof r.mergeType}", equal to ${JSON.stringify(r.mergeType,null,4)}`);if(typeof r.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof r.joinRangesThatTouchEdges}", equal to ${JSON.stringify(r.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(e,null,4)} (type ${typeof e})`);else r=p({},A);let g=n.filter(o=>Array.isArray(o)).map(o=>[...o]).filter(o=>o[2]!==void 0||o[0]!==o[1]),s,a,i;r.progressFn?s=T(g,{progressFn:o=>{i=Math.floor(o/5),i!==a&&(a=i,r.progressFn(i))}}):s=T(g);let l=s.length-1;for(let o=l;o>0;o--)r.progressFn&&(i=Math.floor((1-o/l)*78)+21,i!==a&&i>a&&(a=i,r.progressFn(i))),(s[o][0]<=s[o-1][0]||!r.joinRangesThatTouchEdges&&s[o][0]<s[o-1][1]||r.joinRangesThatTouchEdges&&s[o][0]<=s[o-1][1])&&(s[o-1][0]=Math.min(s[o][0],s[o-1][0]),s[o-1][1]=Math.max(s[o][1],s[o-1][1]),s[o][2]!==void 0&&(s[o-1][0]>=s[o][0]||s[o-1][1]<=s[o][1])&&s[o-1][2]!==null&&(s[o][2]===null&&s[o-1][2]!==null?s[o-1][2]=null:s[o-1][2]!=null?+r.mergeType==2&&s[o-1][0]===s[o][0]?s[o-1][2]=s[o][2]:s[o-1][2]+=s[o][2]:s[o-1][2]=s[o][2]),s.splice(o,1),o=s.length);return s.length?s:null}var L=O;function m(n){return n!=null}function h(n){return Number.isInteger(n)&&n>=0}function f(n){return typeof n=="string"}var S={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},V=class{constructor(e){R(this,"ranges");R(this,"opts");let t=p(p({},S),e);if(t.mergeType&&t.mergeType!==1&&t.mergeType!==2)if(f(t.mergeType)&&t.mergeType.trim()==="1")t.mergeType=1;else if(f(t.mergeType)&&t.mergeType.trim()==="2")t.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);this.opts=t,this.ranges=[]}add(e,t,r){if(e==null&&t==null)return;if(m(e)&&!m(t)){if(Array.isArray(e)){if(e.length){if(e.some(a=>Array.isArray(a))){e.forEach(a=>{Array.isArray(a)&&this.add(...a)});return}e.length&&h(+e[0])&&h(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(t,null,0)})`)}else if(!m(e)&&m(t))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(t,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let g=+e,s=+t;if(h(r)&&(r=String(r)),h(g)&&h(s)){if(m(r)&&!f(r)&&!h(r))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof r}, equal to:
${JSON.stringify(r,null,4)}`);if(m(this.ranges)&&Array.isArray(this.last())&&g===this.last()[1]){if(this.last()[1]=s,this.last()[2]===null||r===null,this.last()[2]!==null&&m(r)){let a=this.last()[2]&&this.last()[2].length>0&&(!this.opts||!this.opts.mergeType||this.opts.mergeType===1)?`${this.last()[2]}${r}`:r;this.opts.limitToBeAddedWhitespace&&(a=$(a,this.opts.limitLinebreaksCount)),f(a)&&!a.length||(this.last()[2]=a)}}else{this.ranges||(this.ranges=[]);let a=r!==void 0&&!(f(r)&&!r.length)?[g,s,r&&this.opts.limitToBeAddedWhitespace?$(r,this.opts.limitLinebreaksCount):r]:[g,s];this.ranges.push(a)}}else throw h(g)&&g>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof s}" equal to: ${JSON.stringify(s,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof g}" equal to: ${JSON.stringify(g,null,4)}`)}push(e,t,r){this.add(e,t,r)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=N(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>m(e[2])?[e[0],e[1],$(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&h(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};return F(k);})();
/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 5.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */
/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 6.0.12
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */
